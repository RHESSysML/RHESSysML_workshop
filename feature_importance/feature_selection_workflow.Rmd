---
title: "Feature Selection Framework"
author: "RHESSysML Capstone Group"
date: "2/5/2022"
output: 
  rmarkdown::html_document:
    theme: cerulean
---

# Introduction

The following R Markdown document describes the necessary steps to determine important relationships between predictor variables and a response variable in RHESSys model output. Specific code examples will be based on RHESSys model output from the Sagehen Creek Experimental Watershed in the Sierra Nevada, CA. The data set incorporates model parameter uncertainty, topographic spatial variability, and climate change scenarios. The data set and associated metadata can be accessed here: <https://www.hydroshare.org/resource/2a31bd57b7e74c758b7857679ffbb4c5/>.

The following research question will be addressed in this process: **What are the most important predictors of Net Primary Productivity in differing climate scenarios?**

# Setup

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

options(scipen=999)

# Standard packages
library(tidyverse)
library(here)
library(patchwork)
library(psych)
library(kableExtra)
library(zeallot)
library(DT)

# Machine Learning packages
library(caret)
library(spatialRF)
library(randomForest)
library(party)
library(partykit)
library(permimp)
library(rfUtilities)
library(randomForestExplainer)
```

# Data Preparation

## Load Data

```{r load_data, message=FALSE}
df <- read_csv(here("data", "sageres.csv")) 
```

## Clean and Aggregate Data

First, RHESSys output will need to be aggregated and cleaned based on specific research question. Possible changes include:

1.  Changing the temporal resolution (i.e. Daily to Yearly measurements).

2.  Converting variable units (i.e. Radians to Degrees).

3.  Converting variable class (i.e. numeric/character to factor).

4.  Creating derived variables (i.e. Peak SWE).

The code chunk below identifies the variables in our data set that will be converted to factors, variables that will be used to aggregate by water year, and the desired response variable. Change the inputs below to apply to your dataset in whatever way necessary. 

The `group_cols` object selects the columns that the user wants the raw dataset to be aggregated by. 

The `factor_vars` object are the predictor variables that will be converted to class factor, which allows the random forest workflow to function. Any predictor variables that should be factors instead of class numeric or character should be converted. (Example: stratumID is class numeric, but because there are 6 different strata, it makes more sense for them to be class factor.)

The `response_var` object is the response variable that the user wants to predict. There should only be one response variable listed at a time.

```{r user_inputs}
group_cols <- c("wy", "stratumID", "clim", "scen", "topo")
factor_vars <- c("wy", "stratumID", "clim", "scen", "topo")
response_var <- "npp"
```

```{r input_tests}
# Check class types
if (class(group_cols) != "character") {
  stop("The group columns specified above should be written as characters.")
}
if (class(factor_vars) != "character") {
  stop("The factor columns specified above should be written as characters.")
}
if (class(response_var) != "character") {
  stop("The response variable column specified above should be written as a character.")
}

# Check for factors with many categories
for (column in factor_vars) {
  num_categories = n_distinct(df[,column])
  if (num_categories > 50) {
    warning(paste(column, "has", num_categories, "categories, should this column be numeric?"))
  }
}
```

Next, the necessary modifications to the data set are made. For this example, we are converting factor variables, aggregating by water year, changing `slope` and `aspect` from radians to degrees, and adding two derived variables: `peak_swe` and `swe_precip_ratio`. Since this data set contains two climate scenarios, we split these up into two data frames.

```{r prepare_data}
# Convert categorical variables to factors
df[,factor_vars] <- lapply(df[,factor_vars], factor)

# Change aspect and slope from radians to degrees
df_wy <- df %>% 
  mutate(aspect=aspect*(180/pi),
         slope=slope*(180/pi))

# Group by chosen columns
df_wy <- df_wy %>%   
  group_by(across(all_of(group_cols)))
```

```{r aggregate_temp_function}
aggregate_temp <- function(df,
                           resolution='season',
                           winter=c(12, 1, 2, 3),
                           spring=c(4, 5),
                           summer=c(6, 7, 8, 9),
                           fall=c(10, 11)) {
  
  if (resolution == 'month') {
  
  months <- c('jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', 'dec')
    
    for (i in seq_along(months)) {
      column_name <- paste0(months[i], '_tavg')
      df_temp_agg[[column_name]] <- mean(df_temp_agg$tavg[df_temp_agg$month == i])
    }
  }
  
  if (resolution == 'season') {

    df_temp_agg <- df %>%
      mutate(winter_tavg = mean(tavg[month %in% (winter)]),
             spring_tavg = mean(tavg[month %in% (spring)]),
             summer_tavg = mean(tavg[month %in% (summer)]),
             fall_tavg = mean(tavg[month %in% (fall)])) 
  }
  
  return(df_temp_agg)
  
  warning("If the season arguments are left blank, this function defaults to 
        winter=c(12, 1, 2, 3), spring=c(4, 5), summer=c(6, 7, 8, 9), fall=c(10, 11)")
}
```

```{r prepare data cont.}
# Aggregate average temperatures
df_wy <- aggregate_temp(df_wy, 'season')

# Create features for peak swe and the peak_swe/precip ratio
df_wy <- df_wy %>% 
  mutate(peak_swe=max(swe)) %>%
  mutate(swe_precip_ratio=peak_swe/sum(precip)) %>% 
  summarise_if(is.numeric, mean) %>% 
  ungroup()

# Rename chosen response variable to "response"
df_wy <- df_wy %>% 
  rename("response" = response_var)

# Reorder response variables first and remove any unwanted variables (manually?)
df_wy <- df_wy %>% 
  select(response, everything()) %>%
  select(-c(tavg, day, month, year, basinID, hillID, zoneID, patchID))

# Create data frame with only climate scenario 0
df_wy0 <- df_wy %>% 
  filter(clim==0) %>% 
  select(-c(clim, wy))

# Create data frame with only climate scenario 2
df_wy2 <- df_wy %>% 
  filter(clim==2) %>% 
  select(-c(clim, wy))
```

Now, we have two data tables representing the two climate scenarios.

Here we'll save the newly aggregated datesets to be automatically uploaded to the Shiny App.

```{r}
# For the final product, this will save the aggregated datasets as csv files that will get overwritten if the user changes the way they preppared their data, or if they use a new dataset. While we are working on this project we will comment this code out so that new files don't get written everytime. If the user wants to save older versions of their aggregated data, they just need to give it a unique name every time they run this code.

# write.csv(df_wy, file = here("shiny", "aggregated_datasets", "df_wy.csv"), row.names = FALSE)
# write.csv(df_wy0, file = here("shiny", "aggregated_datasets", "df_wy0.csv"), row.names = FALSE)
# write.csv(df_wy2, file = here("shiny", "aggregated_datasets", "df_wy2.csv"), row.names = FALSE)
```


# Data Description

Next, we want to get a summary description of the data set. This is crucial for many reasons:

1.  Shows early on in the process if any variables do not have the expected range, magnitude, class, etc.

2.  Provides information on data set characteristics that are important for decisions later on in the machine learning process.

Here, we display summary statistics for the base climate scenario data.

```{r describe_data}
summarize_data <- function(df) {
  df_name <- deparse(substitute(df))
  describe(df) %>% 
    select(vars, n, mean, sd, min, max, range) %>% 
    mutate(class = lapply(df, class)) %>% 
    DT::datatable(options = list(pageLength = 7),
                  caption = paste0("Summary of ", df_name))
}

summarize_data(df_wy0)
#summarize_data(df_wy2)
```

We can also look at the key study area characteristics. In this study, there are six study areas.

```{r describe_strata}
strata <- df_wy %>%
  filter(clim==0) %>% 
  select(c(stratumID, topo, elev, aspect, slope)) %>%
  group_by(stratumID, topo) %>% 
  summarize_if(is.numeric, mean) %>% 
  mutate(topo = case_when(topo == "M" ~ "Mid-Slope",
                          topo == "U" ~ "Upslope",
                          topo == "R" ~ "Riparian")) %>%
  dplyr::arrange(topo) %>%
  rename("Stratum"=stratumID,
         "Topo"=topo,
         "Elevation (m)"=elev,
         "Aspect (degrees CCW from East)"=aspect,
         "Slope (degrees)"=slope)

DT::datatable(strata,
              caption = "Summary of 6 Study Areas in Sagehen Creek")
```

# Remove Multicollinearity

Highly correlated predictor variables are not as much a concern in machine learning when creating a predictive model. However, for this process of assessing relative predictor variable importance, multicollinear variables have biased importance (Strobl et al. 2008). Therefore, these need to be handled prior to assessing feature importance.

## Identify and Remove Correlated Variables

First, we create data frames containing only the predictor variables to assist with the next steps.

```{r get_predictors}
# Save data frames of predictor variables for first climate scenario
num_preds.df_wy0 <- df_wy0 %>% 
  select(!response & where(is.numeric))

factor_preds.df_wy0 <- df_wy0 %>% 
  select(!response & where(is.factor)) %>% 
  colnames()

# Save data frames of predictor variables for second climate scenario
num_preds.df_wy2 <- df_wy2 %>% 
  select(!response & where(is.numeric))

factor_preds.df_wy2 <- df_wy2 %>% 
  select(!response & where(is.factor)) %>% 
  colnames()
```

Next, we use Variance Inflation Factors (VIF) and Pearson Correlation Coefficients to remove variables with high multicollinearity. The functions allow the user to define an order of preference for the selection of variables. Below, there are two methods for setting preference order: (1) Manually creating an ordered vector of column names, or (2) Allowing a preliminary random forest method to determine preference order based on variable importance. While highly correlated variables will not be in the correct order here, their relative importance should be reasonably accurate. The second method is used by default. 

```{r manual_preference_order}
# Preference order can be determined manually for variables of interest:

#preference.order0 <- c("precip", "rz_storage", "trans", "evap")
#preference.order2 <- c("precip", "rz_storage", "trans", "evap")
```


```{r auto_preference_order}
# First climate scenario

# Find preliminary importance using random forest
imp0 <- train(x=df_wy0 %>% select(!response),
              y=df_wy0$response,
              method='rf',
              importance=TRUE,
              replace=TRUE,
              trControl=trainControl(method="none", seed=4326))

# Set preference order based on variable importance
preference.order0 <- varImp(imp0$finalModel, scale=FALSE) %>% 
  arrange(-Overall) %>% 
  rownames()

# Second climate scenario

# Find preliminary importance using random forest
imp2 <- train(x=df_wy2 %>% select(!response),
              y=df_wy2$response,
              method='rf',
              importance=TRUE,
              replace=TRUE,
              trControl=trainControl(method="none", seed=4326))

# Set preference order based on variable importance
preference.order2 <- varImp(imp2$finalModel, scale=FALSE) %>% 
  arrange(-Overall) %>% 
  rownames()
```

```{r create_correlation_functions}
# Remove variables based on VIF and Correlation thresholds
remove_vif <- function(predictors.df, vif.threshold=5, preference.order=preference.order0) {
  if (!(class(vif.threshold) %in% c("numeric"))) {
    stop("VIF threshold must be numeric.")
  }
  if (vif.threshold < 1) {
    stop("VIF threshold must be greater than or equal to 1.")
  }
  
  variable.selection <- auto_vif(x=predictors.df,
                                 vif.threshold=vif.threshold,
                                 preference.order=preference.order) 
  
  return(variable.selection)
}

remove_cor <- function(predictors.df, cor.threshold=0.75, preference.order=preference.order0) {
  if (!(class(cor.threshold) %in% c("numeric"))) {
    stop("Correlation threshold must be numeric.")
  }
  if(cor.threshold < 0 | cor.threshold > 1) {
    stop("Correlation threshold must be between 0 and 1.")
  }
  
  variable.selection <- auto_cor(x=predictors.df,
                                 cor.threshold=cor.threshold,
                                 preference.order=preference.order) 
  
  return(variable.selection)
}
```

Thresholds for VIF and correlation can be set using the function below, with default values of 5 and 0.75, respectively.

```{r remove_multicollinearity, warning=FALSE}
# Create list of selected variables
wy0_vif <- remove_vif(num_preds.df_wy0, vif.threshold=5, preference.order0)$selected.variables
wy0_cor <- remove_cor(num_preds.df_wy0, cor.threshold=0.75, preference.order0)$selected.variables
wy0_select_variables <- unique(append(wy0_vif, wy0_cor))

wy2_vif <- remove_vif(num_preds.df_wy2, vif.threshold=5, preference.order2)$selected.variables
wy2_cor <- remove_cor(num_preds.df_wy2, cor.threshold=0.75, preference.order2)$selected.variables
wy2_select_variables <- unique(append(wy2_vif, wy2_cor))

# Remove numeric variables with multicollinearity
df_wy0_reduced <- df_wy0 %>% 
  select(c(response, all_of(factor_preds.df_wy0), all_of(wy0_select_variables)))

df_wy2_reduced <- df_wy2 %>% 
  select(c(response, all_of(factor_preds.df_wy2), all_of(wy2_select_variables)))
```

## Summary of Removed Variables

```{r}
# Create df with preliminary variable importance (and rank) and whether each was selected or removed
removed_importance0 <- imp$variable.importance %>% 
  data.frame() %>% 
  rownames_to_column("variable") %>%
  rename("importance" = ".") %>% 
  mutate("importance_rank" = rank(-importance)) %>% 
  mutate(selected = case_when(variable %in% wy0_select_variables ~ "selected",
                              !variable %in% wy0_select_variables ~ "removed")) %>% 
  relocate("selected", .after = "variable")

# creating df of VIFs
removed_vif0 <- vif(allpredictors.df_wy0)

# joining dfs to create summary table of removed and selected variables
removed_summary0 <- removed_importance0 %>% 
  left_join(removed_vif0, by = "variable")

# create df of only removed variables
removed_corr0 <- df_wy0[-which(names(df_wy0) %in% c(wy0_select_variables, group_cols))]

removed_imp0_plot <- ggplot(removed_summary0, aes(x = importance, y = reorder(variable, importance), fill = selected)) +
  geom_col() +
  labs(x = "Preliminary Importance", y = "Variable")

removed_vif0_plot <- ggplot(removed_summary0, aes(x = vif, y = reorder(variable, vif), fill = selected)) +
  geom_col() +
  labs(x = "Variable Inflation Factor", y = "Variable")

removed_pairs_plot <- GGally::ggpairs(removed_corr0)

removed_summary0 %>%
  select(-importance) %>% 
  kable(caption="Selected and removed variables",
                            format.args=list()) %>% 
  kable_styling(bootstrap_options = c("striped", "hover"))

removed_imp0_plot
removed_vif0_plot
removed_pairs_plot
```

# Feature Importance

Now, the data frames are adequately prepared to determine predictor feature importance. In this framework, we use the Random Forest because this method has been proven to be able to make predictions and assess feature importance with a high degree of accuracy in numerous applications including ecological analysis (Cutler et al. 2007; Prasad et al. 2006). Additionally, Random Forest requires relatively less hyper-parameter tuning than other common techniques.

### Hyper-Parameter Tuning

A primary advantage of using a random forest model is that there is relatively little hyper-parameter tuning needed. Below, we tune the `mtry` parameter, which determines the number of variables randomly sampled as candidates at each split. The default value for regression is p/3, where p is the number of predictor variables.

```{r tuning_function}
df_wy0_reduced <- as.data.frame(df_wy0_reduced)
df_wy2_reduced <- as.data.frame(df_wy2_reduced)

tune_rf_model <- function(df) {
  
  tuning <- vector(length = (ncol(df)-1))
  
  x=df[,-1]
  y=df[,1]
  
  for (i in 1:length(tuning)) {
    rf_tuning <- randomForest(x, y, mtry = i, ntree = 50)
    tuning[i] <- tail(rf_tuning$mse, 1)
  }
  
  return(tuning)
  
  # bestmtry <- match(min(tuning), tuning)
  # return(bestmtry)
}

```

```{r tune_rf_wy0, warning=FALSE}
set.seed(4326)

mtry0 <- tune_rf_model(df_wy0_reduced)
bestmtry0 <- match(min(mtry0), mtry0)
ggplot(data=as.data.frame(mtry0), aes(x=1:length(mtry0), y=mtry0)) +
  geom_vline(xintercept=bestmtry0, linetype="dashed") +
  geom_point() +
  geom_line() +
  theme_light() +
  labs(x="mtry value",
       y="OOB Error",
       title=paste0("The best mtry value for ", deparse(substitute(df_wy0_reduced)), " is ", bestmtry0))
```

```{r tune_rf_wy2, warning=FALSE}
set.seed(4326)

mtry2 <- tune_rf_model(df_wy2_reduced)
bestmtry2 <- match(min(mtry2), mtry2)
ggplot(data=as.data.frame(mtry2), aes(x=1:length(mtry2), y=mtry2)) +
  geom_vline(xintercept=bestmtry2, linetype="dashed") +
  geom_point() +
  geom_line() +
  theme_light() +
  labs(x="mtry value",
       y="OOB Error",
       title=paste0("The best mtry value for ", deparse(substitute(df_wy2_reduced)), " is ", bestmtry2))
```

### Random Forest Models

```{r get_random_forests}
rf_wy0 <- train(x=df_wy0_reduced %>% select(!response),
                y=df_wy0_reduced$response,
                method='rf',
                .mtry=bestmtry0,
                ntree=500,
                importance=TRUE,
                replace=TRUE,
                trControl=trainControl(method="none", seed=4326))

rf_wy2 <- train(x=df_wy2_reduced %>% select(!response),
                y=df_wy2_reduced$response,
                method='rf',
                .mtry=bestmtry2,
                ntree=500,
                importance=TRUE,
                replace=TRUE,
                trControl=trainControl(method="none", seed=4326))
```

```{r variable_importance}
imp_wy0 <- varImp(rf_wy0$finalModel, scale=FALSE) %>% 
  rownames_to_column("Variable") %>% 
  mutate(Rank=rank(-Overall))

imp_wy2 <- varImp(rf_wy2$finalModel, scale=FALSE) %>% 
  rownames_to_column("Variable") %>% 
  mutate(Rank=rank(-Overall))
```


# Model Evaluation

The following section provides visualizations and statistics to evaluate the random forest performance.

First, simply calling the random forest shows a summary of the results, including percent variance explained.

```{r}
rf_wy0$finalModel
```

The model for the base climate scenario explained 90.34% of variance in NPP.

```{r}
rf_wy2$finalModel
```

The model for the +2 degree Celsius climate scenario explained 88.05% of variance in NPP.

Next, we can implement a permutation test cross-validation for the random forest models.

```{r}
allpredictors.df_wy0_reduced <- df_wy0_reduced %>% 
  select(!response)

rf.crossValidation(x=rf_wy0$finalModel, xdata=allpredictors.df_wy0_reduced, p=0.1, n=10)
```

The results above indicate that, through 10-fold cross validation with 10% of data withheld, the model for the base climate scenario data explains 89.68% of the variance in NPP. This result is 0.66% lower than our original fit % explained.

```{r}
allpredictors.df_wy2_reduced <- df_wy2_reduced %>% 
  select(!response)

rf.crossValidation(x=rf_wy2$finalModel, xdata=allpredictors.df_wy2_reduced, p=0.1, n=10)
```

The results above indicate that, through 10-fold cross validation with 10% of data withheld, the model for the +2 degree Celsius climate scenario data explains 86.99% of the variance in NPP. This result is 1.06% lower than our original fit % explained.

# Visualize Results

Now, we can visualize the results of the Random Forest feature selection.

The following table shows the relative importance of predictor variables between the two climate scenarios.

```{r}
df_imp <- imp_wy0 %>% 
  full_join(imp_wy2, by="Variable") %>% 
  mutate(Diff = Rank.x-Rank.y) %>% 
  select(-c(Overall.x, Overall.y)) %>% 
  rename("Rank (0)" = Rank.x, 
         "Rank (2)" = Rank.y) %>% 
  arrange(`Rank (0)`)

df_imp %>% 
  kable(align="r",
        caption="Difference in variable importance for the two climate scenarios") %>% 
  kable_styling(bootstrap_options = c("striped", "hover")) %>% 
  column_spec(column=4,
              color=ifelse(is.na(df_imp$Diff), "grey",
                           ifelse(df_imp$Diff>0, "green", 
                                  ifelse(df_imp$Diff==0, "grey", "red"))))
```

We see that precipitation and rz_storage are the first and second most important predictors of NPP for both climate scenarios. The highest difference is evaporation - which is third important for the base climate scenario and sixth for the +2 degree Celsius warming scenario. This indicates that the relationship between NPP and evaporation has changed given warming, which could be investigated further. This process can be repeated for all other observations found in the table.

This same information can be plotted below. The variable importance plots also reveal relative magnitude of importance between variables. Note that this is somewhat of an artifact of the mechanics of a random forests model on not necessarily reflective of the actual relative importance of these variables in the natural world.

```{r plot_imp}
plot_imp <- function(varimp_df) {
  df_name <- deparse(substitute(varimp_df))
  ggplot(data=varimp_df, aes(x=Overall, y=reorder(Variable, Overall))) +
    geom_col() +
    theme_light() +
    theme(legend.position = "none",
          axis.text.x = element_blank()) +
    labs(title=paste0("Variable Importance for \n", df_name),
         x="Importance",
         y="Variable")
}

wy0_plot <- plot_imp(imp_wy0)
wy2_plot <- plot_imp(imp_wy2)

wy0_plot + wy2_plot 
```

Let's save the above importance plots to be used in the Shiny App.

```{r, include = FALSE}
importance_plots <- wy0_plot + wy2_plot 
ggsave(importance_plots, filename = "importance_plots.png", path = here("shiny", "www"))
```



## Previewing relationships between important predictors and NPP

The variable importance values derived from our random forest model allow us to investigate intriguing relationships between variables that have been identified as having greater importance.

Here, we investigate the relationships of some of the most important identified variables with NPP as well as their interactions.

```{r}
get_important_predictors <- function(df_imp, rank) {
  df_imp$Variable[df_imp$Rank == rank]
}

# assigning first and second most important variables to objects
pred1_clim0 <- get_important_predictors(imp_wy0, 1)
pred2_clim0 <- get_important_predictors(imp_wy0, 2)
pred1_clim2 <- get_important_predictors(imp_wy2, 1)
pred2_clim2 <- get_important_predictors(imp_wy2, 2)

create_binned_df <- function(df_wy) {
  df_pred_binned <- df_wy %>% 
  select(all_of(pred1_clim0), all_of(pred2_clim0), response) %>%
  mutate(pred1 = df_wy[[pred1_clim0]],
         pred2 = df_wy[[pred2_clim0]]) %>% 
  mutate(bin = as.numeric(ntile(pred2, 4)))
  
  return(df_pred_binned)
}

df0_pred_binned <- create_binned_df(df_wy0)
df2_pred_binned <- create_binned_df(df_wy2)
```

```{r}
ggplot(df0_pred_binned, aes(x = pred1, y = .data[["response"]])) +
  geom_point() +
  geom_smooth(method = "lm") +
  labs(x = str_to_title(pred1_clim0), y = response_var,
       title = paste(pred1_clim0, "vs", response_var,
                     "in 0 degree climate scenario")) +
  theme_minimal()

create_binned_plot <- function(df_binned) {
  df_name <- deparse(substitute(df_binned))
  if (df_name == "df0_pred_binned") {
    p1 = pred1_clim0
    p2 = pred2_clim0
    scen = "0"
  }
  if (df_name == "df2_pred_binned") {
    p1 = pred1_clim2
    p2 = pred2_clim2
    scen = "2"
  }
  
  ggplot(df_binned, aes(x = pred1, y = .data[["response"]])) +
    geom_point() +
    geom_smooth(method = "lm") +
    facet_wrap("bin") +
    labs(x = str_to_title(pred1_clim0), y = response_var,
         title = paste(p1, "vs", response_var, "given different value classes of",
                       p2, "\n in", scen, "degree climate scenario")) +
    theme_minimal()
}

create_binned_plot(df0_pred_binned)
create_binned_plot(df2_pred_binned)
```

Variable interactions can be investigated in many ways. The bivariate partial dependence plot below provides a graphical depiction of the marginal effect of two variables on predicted NPP from the random forest model.

```{r}
# bivariate.partialDependence(x=rf_wy0,
#                             pred.data=allpredictors.df_wy0_reduced,
#                             v1="lai",
#                             v2="peak_swe",
#                             grid.size=15,
#                             col.ramp=c("orange", "green"),
#                             ncols=20)
```

Running this plot for both data sets can demonstrate how variable interactions shift given different climate scenarios.

```{r}
# bivariate.partialDependence(x=rf_wy2,
#                             pred.data=allpredictors.df_wy2_reduced,
#                             v1="lai",
#                             v2="peak_swe",
#                             grid.size=15,
#                             col.ramp=c("orange", "green"),
#                             ncols=20)
```

Variable interactions between two predictors and the corresponding NPP predictions from the random forest model can be displayed as a grid of values.

Below, the x-axis represents values of `rz_storage` , y-axis represents values of `precip` , and the cell colors/values represent predicted values of `npp` , with red indicating high and blue indicating low. For this interaction, we can see that high values of precipitation and root-zone storage result in higher predictions of NPP. This is only true for root zone storage given high precipitation, while high precipitation at all levels of root zone storage predicts relatively higher NPP. This is another indicator that it is an important predictor.

```{r}
plot_predict_interaction(rf_wy0$finalModel, df_wy0_reduced, 
                         "rz_storage", "precip",
                         grid=50) # smaller grid values reveal more general relationships
```

## Comparison with other measures of importance

The capstone team chose to use conditional permutation importance above as our main representation of importance. However there are other potential methods of determining relative importance from random forest models that are demonstrated below. Note that the interpretation of these measures, as discussed in the original justification of using the `permimp` package, is limited due to characteristics of RHESSys data. Namely, the presence of both categorical and continuous variables, differing number of classes in categorical variables, differing scales of numeric variables, and potential remaining multicollinearity all have greater potential to skew the results of the methods below.

The plot below presents the top 10 variables using % mean decrease in accuracy (%IncMSE) and mean decrease in node impurity (IncNodePurity). %IncMSE is computed from permuting the out-of-bag data, while IncNodePurity is the mean total decrease in node impurities from splitting on the given variable, as measured by the residual sum of squares.

```{r}
varImpPlot(rf_wy0$finalModel, n.var=10)
```

The plot below visualizes the distribution of minimum depth from the random forest model. Low values, such as for precipitation below, indicate that many observations are divided into groups based on that variable.

```{r}
min_depth_frame <- min_depth_distribution(rf_wy0$finalModel)

plot_min_depth_distribution(min_depth_frame,
                            mean_sample="relevant_trees")
```

Lastly, SHAP values allow visualization of the direction of these relationships.

```{r}
library(fastshap)

explain0 <- explain(object=rf_wy0$finalModel,
                    X=subset(df_wy0_reduced, select=-npp),
                    pred_wrapper=predict)

autoplot(explain0, type="contribution", feature="npp")
```

## 

# References

Cutler, D. Richard, Thomas C. Edwards, Karen H. Beard, Adele Cutler, Kyle T. Hess, Jacob Gibson, and Joshua J. Lawler. 2007. "Random Forests for Classification in Ecology." *Ecology* 88 (11): 2783--92. <https://doi.org/10.1890/07-0539.1>.

Debeer, Dries, and Carolin Strobl. 2020. "Conditional Permutation Importance Revisited." *BMC Bioinformatics* 21 (1): 307. <https://doi.org/10.1186/s12859-020-03622-2>.

Prasad, Anantha M., Louis R. Iverson, and Andy Liaw. 2006. "Newer Classification and Regression Tree Techniques: Bagging and Random Forests for Ecological Prediction." *Ecosystems* 9 (2): 181--99. <https://doi.org/10.1007/s10021-005-0054-1>.

Strobl, Carolin, Anne-Laure Boulesteix, Achim Zeileis, and Torsten Hothorn. 2007. "Bias in Random Forest Variable Importance Measures: Illustrations, Sources and a Solution." *BMC Bioinformatics* 8 (1): 25. <https://doi.org/10.1186/1471-2105-8-25>.

Strobl, Carolin, Anne-Laure Boulesteix, Thomas Kneib, Thomas Augustin, and Achim Zeileis. 2008. "Conditional Variable Importance for Random Forests." *BMC Bioinformatics* 9 (1): 307. <https://doi.org/10.1186/1471-2105-9-307>.


Assessing feature importance is a complex task with many possible approaches. Tree based models like random forest offer convenient "split-improvement" measures, like mean increase in purity and minimum depth, which are intrinsically derived during model construction. However, these have been shown to be biased towards variables with many categories or large value ranges (Strobl et al. 2007). Permutation importance is another measure that is applied to many model types including random forest---this approach, however, has been shown to be biased towards correlated predictor variables (Strobl et al. 2008). Conditional permutation importance (CPI) is a measure that seeks to assess importance of each feature *conditional* on the other features in the model. This approach tends to offer less biased results and has been used to assess ecosystem dynamics (Strobl et al. 2008). Here we use a recent implementation of CPI developed by Strobl and Debeer (2020), via their `permimp` package.

```{r permimp_graveyard, warning=FALSE}
# imp_wy0 <- permimp(rf0_obj, do_check=FALSE, progressBar=FALSE)
# 
# imp_wy2 <- permimp(rf_wy2$finalModel, do_check=FALSE, progressBar=FALSE)

# imp_to_table <- function(imp) {
#   df_permimp <- imp$values %>%
#     data.frame() %>% 
#     rownames_to_column("Variable") %>% 
#     rename("Importance"=".") %>% 
#     mutate(Rank=rank(-Importance))
# }
# 
# df_imp_wy0 <- imp_to_table(imp_wy0)
# df_imp_wy2 <- imp_to_table(imp_wy2)

# plot_imp <- function(imp_df) {
#   df_name <- deparse(substitute(imp_df))
#   ggplot(data=imp_df, aes(x=Importance, y=reorder(Variable, Importance))) +
#     geom_col() +
#     theme_light() +
#     theme(legend.position = "none",
#           axis.text.x = element_blank()) +
#     labs(title=paste0("Variable Importance for \n", df_name),
#          x="Importance",
#          y="Variable")
# }
```
